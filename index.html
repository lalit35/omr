<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMR Sheet Masking with Answer "A"</title>
    <script src="https://cdn.jsdelivr.net/npm/opencv.js"></script> <!-- OpenCV.js -->
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #canvas {
            margin-top: 20px;
            border: 1px solid #000;
            max-width: 100%;
        }
        #fileInput {
            margin: 10px 0;
        }
        .loading {
            display: none;
            font-weight: bold;
            color: #ff0000;
        }
    </style>
</head>
<body>

<h2>Upload OMR Sheet for Masking (Assume All Answers are "A")</h2>
<input type="file" id="fileInput" accept="image/*">
<div id="loading" class="loading">Processing the OMR Sheet...</div>
<canvas id="canvas"></canvas>

<script>
    // Coordinates for extracting key data (same as before)
    const dataRegions = {
        rollNumber: { x: 240, y: 750, width: 100, height: 50 },
        group: { x: 480, y: 750, width: 100, height: 50 },
        set: { x: 620, y: 750, width: 100, height: 50 },
        mobileNumber: { x: 240, y: 800, width: 200, height: 50 }
    };

    // Coordinates for extracting answers for each section (same as before)
    const questionSections = [
        { x: 284, y: 1640, width: 142, height: 200 },
        { x: 615, y: 1640, width: 118, height: 200 },
        { x: 811, y: 1640, width: 181, height: 200 },
        { x: 1075, y: 1640, width: 181, height: 200 },
        { x: 1339, y: 1640, width: 173, height: 200 }
    ];

    // Handle file input
    document.getElementById('fileInput').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const img = new Image();
                img.src = e.target.result;
                img.onload = function () {
                    processImage(img);
                };
            };
            reader.readAsDataURL(file);
        }
    });

    // Process the image
    function processImage(img) {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        // Initialize OpenCV.js and process the image
        const mat = cv.imread(canvas);
        cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY);  // Convert to grayscale
        cv.adaptiveThreshold(mat, mat, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY, 11, 2);  // Thresholding

        // Add mask and correct answer highlighting (Assume all answers are "A")
        maskAndHighlight(mat);  // Process image with mask and highlight
    }

    // Mask the image and highlight answers (assume all answers are "A")
    function maskAndHighlight(mat) {
        const maskedMat = new cv.Mat(mat.rows, mat.cols, cv.CV_8UC3, [255, 255, 255]);  // White background (255,255,255)

        // Process answers and apply mask
        questionSections.forEach((section, sectionIndex) => {
            const sectionImage = mat.roi(new cv.Rect(section.x, section.y, section.width, section.height));

            // Iterate through 20 questions in each section (Assume "A" for all answers)
            for (let i = 0; i < 20; i++) {
                const bubbleCoordinates = getBubbleCoordinates('A', i);  // Assume "A" for all answers
                const bubble = sectionImage.roi(new cv.Rect(bubbleCoordinates.x, bubbleCoordinates.y, 20, 20));
                const meanColor = cv.mean(bubble);

                // If the bubble is filled (assumed that filled bubbles are darker), retain it in the masked image
                if (meanColor[0] < 100) {
                    // Copy the filled bubble to the masked image (non-white)
                    maskedMat.roi(new cv.Rect(section.x + bubbleCoordinates.x, section.y + bubbleCoordinates.y, 20, 20)).setTo([0, 0, 0]);
                }
                bubble.delete();  // Clean up
            }
            sectionImage.delete();  // Clean up
        });

        // Show the processed image with mask and highlighted answers
        cv.imshow('canvas', maskedMat);
        maskedMat.delete();  // Clean up
    }

    // Get the coordinates for a specific bubble (A, B, C, D) for a question
    function getBubbleCoordinates(option, questionIndex) {
        const bubbleSpacing = 40;  // The horizontal distance between bubbles (A, B, C, D)
        const baseX = 50;  // Start X position for question 1
        const baseY = 40 * questionIndex;  // Start Y position based on the question index
        const offsets = { A: 0, B: 40, C: 80, D: 120 };
        return { x: baseX + offsets[option], y: baseY };
    }

</script>

</body>
</html>
